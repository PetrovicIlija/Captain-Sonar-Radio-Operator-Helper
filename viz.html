<!DOCTYPE html>
<html>

<head>
  <script src="http://d3js.org/d3.v7.min.js" charset="utf-8"></script>
</head>

<body>
  <div class="sonarDiv">
    <input type="range" min="1" max="3" value="1" class="slider" id="rangeSonarType"
      oninput="onChangedSonarType(this.value)">
    <input type="text" placeholder="column row" id="inputSonar">
    <button onclick="eraseDotsUsingSonar()">Use sonar info</button>
  </div>

  <script>
    let x = circleToCircleDistance = 20;
    let offset = 50;
    let dotsMovementDuration = 500;
    let dotsErasingDuration = 500;
    let movementDirectionSquareSize = 40;
    let alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O']
    compassNorthX = 150;
    compassNorthY = 370;
    function drawGrid(svg) {
      svg.selectAll("circle")
        .data(dataset)
        .enter()
        .append("circle")
        .attr("cx", (d) => d[0] * circleToCircleDistance + offset)
        .attr("cy", (d) => d[1] * circleToCircleDistance + offset)
        .attr("r", 5);
      /* .append("label")
      .text(alphabet[(d) => d[0]])
      .attr("x", (d) => d[0] * circleToCircleDistance + offset)
      .attr("y", offset); */
    }


    function moveWest(svg) {
      svg.selectAll("circle")
        .transition()
        .duration(dotsMovementDuration)
        .attr("cx", function () { return d3.select(this).attr("cx") - circleToCircleDistance })
        .on("end", (d, i) => {
          if (i == d3.selectAll("circle").size() - 1) {
            eraseDots(svg);
          }
        });
    }
    function moveNorth(svg) {
      svg.selectAll("circle")
        .transition()
        .duration(dotsMovementDuration)
        .attr("cy", function () { return d3.select(this).attr("cy") - circleToCircleDistance })
        .on("end", (d, i) => {
          if (i == d3.selectAll("circle").size() - 1) {
            eraseDots(svg);
          }
        });
    }
    function moveSouth(svg) {
      svg.selectAll("circle")
        .transition()
        .duration(dotsMovementDuration)
        .attr("cy", function (d, i) { return parseInt(d3.select(this).attr("cy")) + circleToCircleDistance })
        .on("end", (d, i) => {
          if (i == d3.selectAll("circle").size() - 1) {
            eraseDots(svg);
          }
        });
    }
    function moveEast(svg) {
      svg.selectAll("circle")
        .transition()
        .duration(dotsMovementDuration)
        .attr("cx", function () { return parseInt(d3.select(this).attr("cx")) + circleToCircleDistance })
        .on("end", (d, i) => {
          if (i == d3.selectAll("circle").size() - 1) {
            eraseDots(svg);
          }
        });
    }
    function includesPair(toCheckIn, first, second) {
      for (let i = 0; i < islands.length; i++)
        if (toCheckIn[i][0] == first && toCheckIn[i][1] == second) {
          return true;
        }
      return false;
    }
    function coordinateToPosition(c) { return (c - 50) / 20; }
    function positionToCoordinate(position) { return position * 20 + 50; }
    function eraseDots(svg) {
      svg.selectAll("circle")
        .transition()
        .filter(function () {
          return (d3.select(this).attr("cx") < offset) ||
            (d3.select(this).attr("cy") < offset) ||
            (d3.select(this).attr("cx") > offset + circleToCircleDistance * 14) ||
            (d3.select(this).attr("cy") > offset + circleToCircleDistance * 14) ||
            (includesPair(islands, coordinateToPosition(d3.select(this).attr("cx")), coordinateToPosition(d3.select(this).attr("cy"))))
        })
        .duration(dotsErasingDuration)
        .attr("r", 0.1)
        .remove();
    }
    function onChangedSonarType(type) {
      if (type == 1)
        document.getElementById("inputSonar").placeholder = "column row"
      else if (type == 2)
        document.getElementById("inputSonar").placeholder = "column sector"
      else
        document.getElementById("inputSonar").placeholder = "row sector"

    }
  



    function drawIslands(svg){
      for (let i = 0; i < islands.length; i++)
      {
        svg.append("rect")
      .attr("x", positionToCoordinate(islands[i][0]) - circleToCircleDistance/2)
      .attr("y", positionToCoordinate(islands[i][1])- circleToCircleDistance/2)
      .attr("width", circleToCircleDistance)
      .attr("height", circleToCircleDistance)
      .attr("fill", "green")
      }
    }

    function eraseDotsUsingSonar() {
      var slider = document.getElementById("rangeSonarType");
      const sonarValues = document.getElementById("inputSonar").value.split(" ");
      if (slider.value == 1) {
        let x = positionToCoordinate(alphabet.indexOf(sonarValues[0]));
        let y = positionToCoordinate(parseInt(sonarValues[1]) - 1);
        svg.selectAll("circle")
          .transition()
          .filter(function () {
            return !(d3.select(this).attr("cx") == x || d3.select(this).attr("cy") == y)
          })
          .duration(dotsErasingDuration)
          .attr("r", 0.1)
          .remove();
      }
      else if (slider.value == 2) {
        let x = positionToCoordinate(alphabet.indexOf(sonarValues[0]));
        let sector = sonarValues[1] - 1;
        svg.selectAll("circle")
          .transition()
          .filter(function () {
            console.log(x);
            return !(d3.select(this).attr("cx") == x ||
              (
                parseInt(d3.select(this).attr("cx")) >= positionToCoordinate((sector % 3) * 5) &&
                parseInt(d3.select(this).attr("cx")) <= positionToCoordinate((sector % 3) * 5 + 5) &&
                parseInt(d3.select(this).attr("cy")) >= positionToCoordinate(Math.floor(sector / 3) * 5) &&
                parseInt(d3.select(this).attr("cy")) <= positionToCoordinate(Math.floor(sector / 3) * 5 + 5)
              )
            )
          }
          )

          .duration(dotsErasingDuration)
          .attr("r", 0.1)
          .remove();
      }
      else {
        let y = positionToCoordinate(parseInt(sonarValues[0]) - 1);
        let sector = sonarValues[1] - 1;
        svg.selectAll("circle")
          .transition()
          .filter(function () {
            return !((
                parseInt(d3.select(this).attr("cx")) >= positionToCoordinate((sector % 3) * 5) &&
                parseInt(d3.select(this).attr("cx")) <= positionToCoordinate((sector % 3) * 5 + 5) &&
                parseInt(d3.select(this).attr("cy")) >= positionToCoordinate(Math.floor(sector / 3) * 5) &&
                parseInt(d3.select(this).attr("cy")) <= positionToCoordinate(Math.floor(sector / 3) * 5 + 5)
              )|| parseInt(d3.select(this).attr("cy")) == y)
          })
          .duration(dotsErasingDuration)
          .attr("r", 0.1)
          .remove();
      }
    }
    dataset = [];
    islands = [
      [3, 3],
      [10, 5],
      [10, 6],
      [4, 6],
      [1, 11]
    ]
   
    for (let i = 0; i < 15; i++)
      for (let j = 0; j < 15; j++)
        if (!includesPair(islands, i, j))
          dataset.push([i, j]);

    const w = 800;
    const h = 500;
    const xScale = d3.scaleLinear()
      .domain([0, d3.max(dataset, (d) => d[0])])
      .range([offset, offset + circleToCircleDistance * 14]);

    const yScale = d3.scaleLinear()
      .domain([0, d3.max(dataset, (d) => d[1])])
      .range([offset, offset + circleToCircleDistance * 14]);

    const svg = d3.select("body")
      .append("svg")
      .attr("width", w)
      .attr("height", h);
    /* var xAxis = d3.axisTop(xScale)
    var yAxis = d3.axisLeft(yScale);
    svg.append("g")
      .attr("transform", "translate(0," + circleToCircleDistance + ")")
      .call(xAxis);
      svg.append("g")
      .attr("transform", "translate(20, 0)")
      .call(yAxis); */
    svg.selectAll("text")
      .data("ABCDEFGHOJKLMNO")
      .enter()
      .append("text")
      .text((d) => d)
      .attr("x", (d, i) => i * circleToCircleDistance + offset - 6.5)
      .attr("y", 20);
    svg.selectAll("g")
      .data([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
      .enter()
      .append("text")
      .text((d) => d)
      .attr("x", 8)
      .attr("y", (d) => (d - 1) * circleToCircleDistance + offset + 5);

    drawGrid(svg);
    drawIslands(svg);
    north = svg.append("rect")
      .attr("x", compassNorthX)
      .attr("y", compassNorthY)
      .attr("width", movementDirectionSquareSize)
      .attr("height", movementDirectionSquareSize)
      .attr("fill", "lightblue")
      .text("West")
      .on("click", function () { moveNorth(svg) });
    west = svg.append("rect")
      .attr("x", compassNorthX - 40)
      .attr("y", compassNorthY + 40)
      .attr("width", movementDirectionSquareSize)
      .attr("height", movementDirectionSquareSize)
      .attr("fill", "lightblue")
      .on("click", function () { moveWest(svg) });
    east = svg.append("rect")
      .attr("x", compassNorthX + 40)
      .attr("y", compassNorthY + 40)
      .attr("width", movementDirectionSquareSize)
      .attr("height", movementDirectionSquareSize)
      .attr("fill", "lightblue")
      .on("click", function () { moveEast(svg) });
    south = svg.append("rect")
      .attr("x", compassNorthX)
      .attr("y", compassNorthY + 80)
      .attr("width", movementDirectionSquareSize)
      .attr("height", movementDirectionSquareSize)
      .attr("fill", "lightblue")
      .on("click", function () { moveSouth(svg) });
    svg.append("text")
      .attr("x", compassNorthX)
      .attr("y", compassNorthY + 60)
      .text("move")




  </script>
</body>

</html>